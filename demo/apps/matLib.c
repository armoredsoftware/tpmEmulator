/*
 * SPI testing utility (using spidev driver)
 *
 * Copyright (c) 2007  MontaVista Software, Inc.
 * Copyright (c) 2007  Anton Vorontsov <avorontsov@ru.mvista.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License.
 *
 * Cross-compile with cross-gcc -I/path/to/cross-kernel/include
 */
/*
* michael neises
* 20/4/18
*
*/
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/spi/spidev.h>
#include <unistd.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#define uchar unsigned char

#define MAX_RAW     100
#define MAX_COLUMN  8

uchar lPatterns[MAX_RAW][MAX_COLUMN] = {

//waves
    {0x81,0x42,0x24,0x18,0x18,0x24,0x42,0x81},
    {0x42,0x24,0x18,0x18,0x24,0x42,0x81,0x81},
    {0x24,0x18,0x18,0x24,0x42,0x81,0x81,0x42},
    {0x18,0x18,0x24,0x42,0x81,0x81,0x42,0x24},
    {0x18,0x24,0x42,0x81,0x81,0x42,0x24,0x18},
    {0x24,0x42,0x81,0x81,0x42,0x24,0x18,0x18},
    {0x42,0x81,0x81,0x42,0x24,0x18,0x18,0x24},
    {0x81,0x81,0x42,0x24,0x18,0x18,0x24,0x42},
    {0x81,0x42,0x24,0x18,0x18,0x24,0x42,0x81},

//concentric circles

    {0xFF,0x81,0x81,0x81,0x81,0x81,0x81,0xFF},
    {0x00,0x7E,0x42,0x42,0x42,0x42,0x7E,0x00},
    {0xFF,0x81,0xBD,0xA5,0xA5,0xBD,0x81,0xFF},
    {0x00,0x7E,0x42,0x5A,0x5A,0x42,0x7E,0x00},
    {0xFF,0x81,0xBD,0xA5,0xA5,0xBD,0x81,0xFF},
    {0x00,0x7E,0x42,0x5A,0x5A,0x42,0x7E,0x00},

};

uchar blank[8] = {0,0,0,0,0,0,0,0};
uchar lChars[MAX_RAW][MAX_COLUMN] = {

//Alphanumerics
    {0x3C,0x42,0x62,0x52,0x4A,0x46,0x42,0x3C},//0
    {0x10,0x30,0x50,0x10,0x10,0x10,0x10,0x7C},//1
    {0x3E,0x02,0x02,0x3E,0x20,0x20,0x3E,0x00},//2
    {0x00,0x7C,0x04,0x04,0x7C,0x04,0x04,0x7C},//3
    {0x08,0x18,0x28,0x48,0xFE,0x08,0x08,0x08},//4
    {0x3C,0x20,0x20,0x3C,0x04,0x04,0x3C,0x00},//5
    {0x3C,0x20,0x20,0x3C,0x24,0x24,0x3C,0x00},//6
    {0x3E,0x22,0x04,0x08,0x08,0x08,0x08,0x08},//7
    {0x00,0x3E,0x22,0x22,0x3E,0x22,0x22,0x3E},//8
    {0x3E,0x22,0x22,0x3E,0x02,0x02,0x02,0x3E},//9
    {0x08,0x14,0x22,0x3E,0x22,0x22,0x22,0x22},//A
    {0x3C,0x22,0x22,0x3E,0x22,0x22,0x3C,0x00},//B
    {0x3C,0x40,0x40,0x40,0x40,0x40,0x3C,0x00},//C
    {0x7C,0x42,0x42,0x42,0x42,0x42,0x7C,0x00},//D
    {0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x7C},//E
    {0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x40},//F
    {0x3C,0x40,0x40,0x40,0x40,0x44,0x44,0x3C},//G
    {0x44,0x44,0x44,0x7C,0x44,0x44,0x44,0x44},//H
    {0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x7C},//I
    {0x3C,0x08,0x08,0x08,0x08,0x08,0x48,0x30},//J
    {0x00,0x24,0x28,0x30,0x20,0x30,0x28,0x24},//K
    {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7C},//L
    {0x81,0xC3,0xA5,0x99,0x81,0x81,0x81,0x81},//M
    {0x00,0x42,0x62,0x52,0x4A,0x46,0x42,0x00},//N
    {0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C},//O
    {0x3C,0x22,0x22,0x22,0x3C,0x20,0x20,0x20},//P
    {0x1C,0x22,0x22,0x22,0x22,0x26,0x22,0x1D},//Q
    {0x3C,0x22,0x22,0x22,0x3C,0x24,0x22,0x21},//R
    {0x00,0x1E,0x20,0x20,0x3E,0x02,0x02,0x3C},//S
    {0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08},//T
    {0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x1C},//U
    {0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18},//V
    {0x00,0x49,0x49,0x49,0x49,0x2A,0x1C,0x00},//W
    {0x00,0x41,0x22,0x14,0x08,0x14,0x22,0x41},//X
    {0x41,0x22,0x14,0x08,0x08,0x08,0x08,0x08},//Y
    {0x00,0x7F,0x02,0x04,0x08,0x10,0x20,0x7F},//Z
    {0x28,0x28,0x28,0x28,0x28,0x28,0x00,0x28},// !
    {0x00,0xCC,0x22,0x22,0xCC,0x88,0x00,0x88},// ?
    {0x00,0x24,0x24,0x00,0x42,0x24,0x18,0x00},// :)
    {0x00,0x24,0x24,0x00,0x18,0x24,0x42,0x00},// :( 
};

static void pabort(const char *s) {
    perror(s);
    abort();
}

static const char *device_spidev0_0 = "/dev/spidev0.0";
static const char *device_spidev1_0 = "/dev/spidev1.0";
static uint8_t mode;
static uint8_t bits = 8;
static uint32_t speed = 500000;

static void transfer(int fd, uchar address1, uchar dat1, uchar address2, uchar dat2) {
    int ret;
    uint8_t tx[] = {
        address1, dat1, address2, dat2
    };
    uint8_t rx[ARRAY_SIZE(tx)] = {0, };

    struct spi_ioc_transfer tr;

    memset(&tr, 0, sizeof(tr));
    tr.tx_buf = (unsigned long)tx;
    tr.rx_buf = (unsigned long)rx;
    tr.len = ARRAY_SIZE(tx);
    tr.speed_hz = speed;
    tr.bits_per_word = bits;
    tr.delay_usecs = 0;
    tr.cs_change = 0;

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
    if (ret < 1)
        pabort("can't send SPI message");
}

uchar* charDict( char aChar )
{
    switch( aChar )
    {
        case '_' : return blank; break;
        case '^' : return NULL; break;
        case '0' : return lChars[0]; break;
        case '1' : return lChars[1]; break;
        case '2' : return lChars[2]; break;
        case '3' : return lChars[3]; break;
        case '4' : return lChars[4]; break;
        case '5' : return lChars[5]; break;
        case '6' : return lChars[6]; break;
        case '7' : return lChars[7]; break;
        case '8' : return lChars[8]; break;
        case '9' : return lChars[9]; break;
        case 'a' : return lChars[10]; break;
        case 'b' : return lChars[11]; break;
        case 'c' : return lChars[12]; break;
        case 'd' : return lChars[13]; break;
        case 'e' : return lChars[14]; break;
        case 'f' : return lChars[15]; break;
        case 'g' : return lChars[16]; break;
        case 'h' : return lChars[17]; break;
        case 'i' : return lChars[18]; break;
        case 'j' : return lChars[19]; break;
        case 'k' : return lChars[20]; break;
        case 'l' : return lChars[21]; break;
        case 'm' : return lChars[22]; break;
        case 'n' : return lChars[23]; break;
        case 'o' : return lChars[24]; break;
        case 'p' : return lChars[25]; break;
        case 'q' : return lChars[26]; break;
        case 'r' : return lChars[27]; break;
        case 's' : return lChars[28]; break;
        case 't' : return lChars[29]; break;
        case 'u' : return lChars[30]; break;
        case 'v' : return lChars[31]; break;
        case 'w' : return lChars[32]; break;
        case 'x' : return lChars[33]; break;
        case 'y' : return lChars[34]; break;
        case 'z' : return lChars[35]; break;
        case '!' : return lChars[36]; break;
        case '?' : return lChars[37]; break;
        case ')' : return lChars[38]; break;
        case '(' : return lChars[39]; break;
    }
}

void setLeftMatrix(int fd, uchar dictInt)
{
    int i;
    uchar* temp = charDict( dictInt );
    if( temp != NULL )
    {
        for(i = 1; i < MAX_COLUMN+1; i++)
        {
            //fprintf(stderr, "here is this %d\n", (uchar)(*(temp-1 + i)) );
            transfer(fd, 0, 0, i, (uchar)(*(temp-1 + i)) );
        }
    }
}

void setRightMatrix(int fd, uchar dictInt)
{
    int i;
    uchar* temp = charDict( dictInt );
    if( temp != NULL )
    {
        for(i = 0; i < MAX_COLUMN+1; i++)
        {
            transfer(fd, i, (uchar)(*(temp-1 + i)), 0, 0);
        }
    }
}

void setBothMatrices(uchar left, uchar right)
{
    int fd;

    fd = open(device_spidev0_0, O_RDWR);
    if (fd < 0) {
        //printf("can't open /dev/spidev0.0\nTry /dev/spidev1.0\n");
        fd = open(device_spidev1_0, O_RDWR);
        if (fd < 0)
            pabort("can't open /dev/spidev1.0");
    }
    
    setLeftMatrix( fd, left );
    setRightMatrix( fd, right );

    close(fd);
}

void cleanLeftMatrix(int fd)
{
    int i;
    setLeftMatrix(fd, '_');
}

void cleanRightMatrix(int fd)
{
    int i;
    for(i = 0; i < MAX_COLUMN; i++)
    {
        transfer(fd, i+1, blank[i], 0, 0);
    }

}

void cleanBothMatrices()
{
    int fd;

    fd = open(device_spidev0_0, O_RDWR);
    if (fd < 0) {
        //printf("can't open /dev/spidev0.0\nTry /dev/spidev1.0\n");
        fd = open(device_spidev1_0, O_RDWR);
        if (fd < 0)
            pabort("can't open /dev/spidev1.0");
    }
    
    cleanLeftMatrix( fd );
    cleanRightMatrix( fd );

    close(fd);

}
